const ary_com = require("nv-array-combo");

const ABBR_MD = {
    e:"enumerable",
    w:"writable",
    c:"configurable",
    enumerable:"e",
    writable:"w",
    configurable:"c"
}



function creat_func_descs() {
    let arr = ['e','w','c']
    let g = ary_com.comb(arr)
    let l = Array.from(g)
    l = l.filter(r=>r.length>0)
    let ltrue = l.map(r=>[true].concat(r))
    let lfalse = l.map(r=>[false].concat(r))
    return(ltrue.concat(lfalse))
}


function creat_fname_from_desc(desc) {
    return(desc[0].toString()+'_'+desc.slice(1).join(""))
}

function creat_func_from_desc(desc) {
    let val = desc[0]
    let ks = desc.slice(1).map(k=>ABBR_MD[k])
    let entries = ks.map(r=>[r,val])
    let cfg = Object.fromEntries(entries)
    let f = function(obj,...props) {
        props.forEach(
            prop=>{Object.defineProperty(obj,prop,cfg);}
        );
    }
    Object.defineProperty(f,'name',{value:creat_fname_from_desc(desc)})
    return(f)
}

function add_funcs_to_mod() {
    let descs = creat_func_descs()
    descs.forEach(
        desc=>{
            let f = creat_func_from_desc(desc);
            module.exports[f.name] =f;
        }
    );
    module.exports['ABBR_MD'] = ABBR_MD
}

add_funcs_to_mod();



////

const BUITIN_PROP_REGEX = /^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/

function copy_props_from(target, source) {
    Object.getOwnPropertyNames(source)
        .concat(Object.getOwnPropertySymbols(source))
        .forEach(
            (prop) => {
                if (prop.match(BUITIN_PROP_REGEX)) {return}
                Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))
            }
        )
}


module.exports.BUITIN_PROP_REGEX = BUITIN_PROP_REGEX
module.exports.copy_props_from = copy_props_from



